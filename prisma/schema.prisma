datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

generator client {
  provider = "prisma-client-js"
}

// ---------------------------------------------------------------------------------------------
// NextAuth.js models
// ---------------------------------------------------------------------------------------------

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id            String            @id @default(cuid())
  name          String?
  displayName   String?
  email         String?           @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  Build         Build[]
  BuildVotes    BuildVoteCounts[]
  BuildReports  BuildReports[]
  BannedUsers   BannedUsers[]
  PaidUsers     PaidUsers[]
  UserItems     UserItems[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ---------------------------------------------------------------------------------------------
// Other models
// ---------------------------------------------------------------------------------------------

enum ITEM_CATEGORY {
  helm
  torso
  legs
  gloves
  relic
  amulet
  weapon
  archtype
  concoction
  consumable
  mod
  mutator
  relicfragment
  ring
  skill
  trait
}

enum ITEM_DLC {
  base
  dlc1
}

model Item {
  id         String       @id @default(cuid())
  itemId     String       @unique
  dlc        ITEM_DLC     @default(base)
  BuildItems BuildItems[]
  UserItems  UserItems[]
}

model UserItems {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  item   Item   @relation(fields: [itemId], references: [id], onDelete: Cascade)
  itemId String

  @@index([userId])
  @@index([itemId])
}

model Build {
  id              String            @id @default(cuid())
  createdAt       DateTime          @default(now())
  updatedAt       DateTime?         @updatedAt
  createdBy       User              @relation(fields: [createdById], references: [id])
  createdById     String
  isPublic        Boolean           @default(true)
  isFeaturedBuild Boolean           @default(false)
  name            String
  description     String?           @db.Text
  videoUrl        String?
  thumbnailUrl    String?
  helm            String?
  torso           String?
  legs            String?
  gloves          String?
  relic           String?
  amulet          String?
  weapon          String?
  ring            String?
  archtype        String?
  skill           String?
  concoction      String?
  consumable      String?
  mod             String?
  mutator         String?
  relicfragment   String?
  trait           String?
  BuildVotes      BuildVoteCounts[]
  BuildReports    BuildReports[]
  BuildItems      BuildItems[]

  @@index([createdById])
}

model BuildItems {
  id       String  @id @default(cuid())
  build    Build   @relation(fields: [buildId], references: [id], onDelete: Cascade)
  buildId  String
  item     Item    @relation(fields: [itemId], references: [id], onDelete: Cascade)
  itemId   String
  category String?
  index    Int?
  amount   Int?

  @@index([buildId])
  @@index([itemId])
}

model BuildVoteCounts {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
  build     Build     @relation(fields: [buildId], references: [id], onDelete: Cascade)
  buildId   String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  @@index([buildId])
  @@index([userId])
}

model BuildReports {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  build     Build    @relation(fields: [buildId], references: [id], onDelete: Cascade)
  buildId   String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  reason    String

  @@index([buildId])
  @@index([userId])
}

model BannedUsers {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  reason    String

  @@index([userId])
}

model PaidUsers {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
  userId    String

  @@index([userId])
}
